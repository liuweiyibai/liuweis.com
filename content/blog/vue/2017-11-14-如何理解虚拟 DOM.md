---
title: 如何理解虚拟 DOM
category:
  - React
  - Vue
date: 2017-11-14 17:56:28
---

脱离框架，介绍一下为什会出现虚拟 DOM，以及虚拟 DOM 的优缺点，简单的虚拟 DOM 的实现方式。

## 虚拟 DOM

**什么是虚拟 DOM?**

所谓虚拟 DOM (Virtual DOM)就是使用 JavaScript 对象树来表示一个 DOM 结构。

虚拟 DOM 并没有完全实现 DOM，虚拟 DOM 最主要的还是保留了 DOM 元素之间的层次关系和一些基本属性。因为真实 DOM 实在是太复杂，属性很多。虚拟 DOM 里每一个节点实际上只有几个属性组成了一个棵对象树，构成的虚拟 DOM 树比真实的 DOM 树更加轻量。

**为什么会出现虚拟 DOM?**

首先就是当很复杂的页面结构，需要频繁的根据数据去显隐 DOM、去更改样式、去计算哪些状态需要保留等等，当我们的 web 应用很大，类似这样的场景会有很多，这样做会导致的后果就是，随着应用程序越来越复杂，需要在 JavaScript 里面维护的字段也越来越多，需要监听事件和在事件回调用更新页面的 DOM 操作也越来越多，应用程序会变得非常难维护。

然后出现了一些前端框架，在模版中声明视图组件是和什么状态进行绑定的，双向绑定引擎就会在状态更新的时候自动更新视图，比如 Ng1。这种框架可以帮助我们直接通过数据去驱动视图的变化，当数据变化不用我们手动操作 DOM 去更改视图。

这样做最直观的是会产生一些性能问题，每次数据修改可能面临很多次的几何排列，这个过程可能造成浏览器的多次重绘重排，导致占用过多浏览器资源，一个小小的状态变更都会导致整棵树重新构造。

所以出现了虚拟 DOM，作为数据和真实 DOM 的中间层，当数据发生变化时，重新生成一个虚拟 DOM 树，新旧两颗虚拟 DOM 树比较差异，实现对真实 DOM 节点的复用，以及最小更新。

## 使用代码来描述一个简单的 VDOM

相对于 DOM 对象，原生的 JavaScript 对象处理起来更快，而且更简单。DOM 树上的结构、属性信息我们都可以很容易地用 JavaScript 对象表示出来：

比如有这么一段 HTML 代码:

```html
<ul id="list">
  <li class="item">Item 1</li>
  <li class="item">Item 2</li>
  <li class="item">Item 3</li>
</ul>
```

使用 JavaScript 对象来表示这段 HTML:

```js
var element = {
  tagName: 'ul', // 节点标签名
  props: {
    // DOM的属性，用一个对象存储键值对
    id: 'list',
  },
  children: [
    // 该节点的子节点
    { tagName: 'li', props: { class: 'item' }, children: ['Item 1'] },
    { tagName: 'li', props: { class: 'item' }, children: ['Item 2'] },
    { tagName: 'li', props: { class: 'item' }, children: ['Item 3'] },
  ],
}
```

## 虚拟 DOM 优缺点

**优点**

- 为函数式的 UI 编程方式打开了大门
- 跨平台与分层设计

  虚拟 DOM 本质上是 JavaScript 对象，而真实 DOM 与平台强相关，相比之下虚拟 DOM 带来了分层设计、跨平台以及 SSR 等特性。至于 Virtual DOM 比 原生 DOM 谁的性能好，需要 “控制变量法” 才能比较。这是为什么要设计虚拟 DOM 的主要原因。虚拟 DOM 抽象了原本的渲染过程，实现了跨平台的能力，而不仅仅局限于浏览器的 DOM，可以是安卓和 iOS 的原生组件，也可以是小程序，也可以是各种 GUI。

- 经过 diff 计算以最小的代价更新变化的视图。

  整棵 DOM 树实现代价太高，能否只更新变化的部分的视图。虚拟 DOM 能通过 patch 准确地转换为真实 DOM，并且方便进行 diff。

- 保证性能下限(次要原因)：

  框架的虚拟 DOM 需要适配任何上层 API 可能产生的操作(分层设计)，它的一些 DOM 操作的实现必须是普适的，所以它的性能并不是最优的；但是比起粗暴的 DOM 操作性能要好很多，因此框架的虚拟 DOM 至少可以保证在你不需要手动优化的情况下，依然可以提供还不错的性能，即保证性能的下限。

- 无需手动操作 DOM：

  操作 DOM 慢，JavaScript 运行效率高。我们可以将 DOM 对比(diff 操作)放在 JavaScript 层，提高效率。我们不再需要手动去操作 DOM，只需要写好 View-Model 的代码逻辑，框架会根据虚拟 DOM 和 数据双向绑定，帮我们以可预期的方式更新视图，极大提高我们的开发效率。

- 组件的高度抽象化：

  Vue.2x 引入 VirtualDOM 把渲染过程抽象化，从而使得组件的抽象能力也得到提升，并且可以适配 DOM 以外的渲染目标。不再依赖 HTML 解析器进行模版解析，可以进行更多的 AOT 工作提高运行时效率：通过模版 AOT 编译，Vue 的运行时体积可以进一步压缩，运行时效率可以进一步提升。Virtual DOM 的优势不在于单次的操作，而是在大量、频繁的数据更新下，能够对视图进行合理、高效的更新。为了实现高效的 DOM 操作，一套高效的虚拟 DOM diff 算法显得很有必要.

**缺点**

- 无法进行极致优化：

  虽然虚拟 DOM + 合理的优化，足以应对绝大部分应用的性能需求，但在一些性能要求极高的应用中虚拟 DOM 无法进行针对性的极致优化。

  虽然 Vue 能够保证触发更新的组件最小化，但在单个组件内部依然需要遍历该组件的整个 Virtual DOM 树。

  在一些组件整个模版内只有少量动态节点的情况下，这些遍历都是性能的浪费。

  传统 Virtual DOM 的性能跟模版大小正相关，跟动态节点的数量无关。

## 具体实现过程

通过类似 createElement 函数递归创建出虚拟 DOM 树，渲染到页面上，当数据更新后，重新调用 createElement 生成新的虚拟 DOM 数，完后新旧两棵 DOM 树做比较(diff 过程)，找到两棵树的最小差别后，然后更新映射到真实 DOM 上。

具体 jsx 和 template 编译到 createElement 函数函数调用方式可以查看[Vue 文件解析过程](/blog/vue-file-parsing-process)和[jsx 文件解析过程]()

具体过程可以 Diff 过程可以查看 [Vue2 Diff 算法过程.md](/blog/vue-2-diff-algorithm-principle)和 [React Diff 算法过程]()

## 参考链接

[知乎:网上都说操作真实 DOM 慢，但测试结果却比 React 更快，为什么？](https://www.zhihu.com/question/31809713)
