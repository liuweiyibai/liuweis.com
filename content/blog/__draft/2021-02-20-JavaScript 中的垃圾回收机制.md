---
title: JavaScript 中的垃圾回收机制
date: 2021-02-20 14:07:45
category:
  - JavaScript
---

## 垃圾回收

## 分代回收

- 新生代 —— 就是指存活时间较短的对象，例如：一个局部作用域中，只要函数执行完毕之后变量就会回收。

- 老生代 —— 就是指存活时间较长的对象，例如：全局对象，闭包变量数据。

### 可达性

可达性是 JavaScript 内存管理的主要概念。可访问和可用的值称为可达。基本可达值：

1. 局部变量和当前函数参数。
2. 嵌套调用的当前链上其他函数的参数和变量。
3. 全局变量。

上述值称为根。一旦一个变量可以通过引用链或单个引用从根访问，则称为可达。
一个局部变量内的对象。如果该对象具有引用另一个对象的属性，则该对象称为可达。

> 注意: 被引用与可访问（从一个根）不同：一组相互连接(互相引用)的对象可能整体都不可达。

## 变量的生命周期

JavaScript 的内存生命周期的工作原理如下：

![变量的生命周期](https://cdn.clearlywind.com/blog-images/images/var-life-cycle.png)

在 JavaScript 中，分配和释放阶段是自动的。然而，这并不意味着我们应该只关心内存的使用。像无限循环、错误的递归和回调地狱之类的东西会占满内存并导致内存泄漏。因此，理解分配/释放内存对于上述避免上述情况非常重要。

当一个变量的生命周期结束之后它所指向的内存就应该被释放。在 JavaScript 有全局变量和在函数中产生的局部变量。局部变量的生命周期在函数执行过后就结束了，此时便可将它引用的内存释放（即垃圾回收），但全局变量生命周期会持续到浏览器关闭页面。

当不再使用内存时，JavaScript 如何知道不再使用的内存？通过其垃圾收集器。

### 垃圾收集器

在 JavaScript 中，存在一个后台进程，称为垃圾。它能够监视所有对象并删除无法访问的对象。它的工作是跟踪内存的分配和使用，以便发现何时不再需要一块已分配的内存，然后它会自动释放这块内存。

垃圾回收是自动完成的，我们不能强制执行或是阻止执行。当对象是可达状态时，它一定是存在于内存中的。在 JavaScript 使用两种著名的策略来执行 GC：引用计数技术和标记清除算法。

### 垃圾收集算法

- [引用计数](https://zh.wikipedia.org/wiki/引用计数)

  跟踪记录每个值被引用的次数，当某个变量的引用次数为 0 的时候，该变量就被下一次垃圾回收所回收。

  如果有零个引用指向一个对象，则该对象被认为是可以回收的。

  比如有如下代码:

  ```js
  var bar = {
    name: 'bar',
  }
  bar = null
  ```

  这里创建了两个变量对象：bar 和 name。既然 bar 是在最后一行接收到一个新值，那么 name 就可以进行垃圾回收了。

  再比如：

  ```js
  function check() {
    var bar = {}
    var foo = {}
    bar.name = foo
    foo.name = bar
    return true
  }
  check()
  ```

  就对象而言，JavaScript 是一种基于引用的语言，这意味着实例化对象名称指向内存中的值。

  我们创建一个函数，该函数内部内部 bar 和 foo 互相引用。

  通常，当一个函数完成执行时，它的内部元素会被垃圾收集。但是，在这种情况下，GC 无法执行此操作，因为对象仍然相互引用。

  这就是第二个 JavaScript GC 算法出现的地方：标记和清除算法。

- 标记清除

  该算法通过搜索无法从 JavaScript 的顶级对象（root 全局对象）访问的对象，也就是不可达的变量对象，被回收。

  JavaScript 如何跟踪没一个变量，并且精确做到垃圾回收？

  垃圾收集器在运行的时候会给存储在内存中的所有变量都加上标记，去掉已经被标记为引用的的变量，在此之后再被标记的变量将被视为准备删除的变量。最后垃圾回收器清除标记的变量，回收它们所占用的内存空间。

  目前主流浏览器都是使用标记清除式的垃圾回收策略，只不过收集的间隔有所不同。

  未被引用的变量包括不可达变量，声明未使用的变量，定期执行标记根，标记引用，没有被引用的变量将被回收。

## 总结

垃圾收集是一个自动执行的过程。无论如何都不能强迫或阻止垃圾回收。对象可以在可访问时保留在内存中(闭包)。重要的是要知道被引用与可访问不同。垃圾收集的高级算法由现代引擎执行。

## 参考地址

[前端面试：谈谈 JS 垃圾回收机制](https://segmentfault.com/a/1190000018605776)

[JavaScript 垃圾回收机制](https://zhuanlan.zhihu.com/p/60336501)

[javascript 垃圾回收机制 - 标记清除法/引用计数/V8 机制](https://segmentfault.com/a/1190000019276047)

[JavaScript 中的垃圾回收和内存泄漏](https://blog.fundebug.com/2019/04/30/javascript-memory-management/)
