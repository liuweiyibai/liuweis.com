---
title: 总结一下 HTTP 协议
date: 2019-04-20 21:18:39
thumbnail: "../../assets/thumbnails/http.png"
category:
  - HTTP
  - 浏览器
---

## 简介

HTTP 协议是 HyperText Transfer Protocol（超文本传输协议）的缩写，它是互联网上应用最为广泛的一种网络协议。用于客户端和服务器之间的通信。请求访问文本或图像等资源的一端称为客户端，而提供资源响应的一端称为服务器端。HTTP 协议处于计算机网络中的应用层，HTTP 是建立在 TCP 协议之上，所以 HTTP 协议的瓶颈及其优化技巧都是基于 TCP 协议本身的特性，例如 tcp 建立连接的 3 次握手和断开连接的 4 次挥手以及每次建立连接带来的 RTT(来回通信延迟) 延迟时间。

> 在计算机网络分层体系结构中，HTTP 属于最顶部的应用层。除了 HTTP 服务外，同属于应用层的还有 FTP、DNS、SSH、Telnet、TLS/SSL、POP、IMAP 等服务或应用程序。HTTP 协议的两端，必定有一个承担了客户端角色，另一个承担的是服务器端角色。

一个经典的 HTTP 通信过程及报文结构如下：

![HTTP](https://cdn.clearlywind.com/blog-images/images/http-client-and-server.png)

## 发展历程

- HTTP/0.9：1991 年发布，极其简单，只有一个 get 命令；
- HTTP/1.0：1996 年 5 月发布，增加了大量内容；
- HTTP/1.1：1997 年 1 月发布，进一步完善 HTTP 协议，是目前最流行的版本；
- SPDY ：2009 年谷歌发布 SPDY 协议，主要解决 HTTP/1.1 效率不高的问题；
- HTTP/2 ：2015 年借鉴 SPDY 的 HTTP/2 发布；

## HTTP

HTTP/1.0 和 HTTP/1.1

HTTP/1.0 最早在网页中使用是在 1996 年，那个时候只是使用一些较为简单的网页上和网络请求上，而 HTTP/1.1 则在 1999 年才开始广泛应用于现在的各大浏览器网络请求中，同时 HTTP/1.1 也是当前使用最为广泛的 HTTP 协议。 主要区别主要体现在：

- 缓存处理

  在 HTTP/1.0 中主要使用 header 里的 If-Modified-Since, Expires 来做为缓存判断的标准，HTTP1.1 则引入了更多的缓存控制策略例如 Entity tag，If-Unmodified-Since, If-Match, If-None-Match 等更多可供选择的缓存头来控制缓存策略。

- 带宽优化及网络连接的使用

  HTTP/1.0 中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP1.1 则在请求头引入了 range 头域，它允许只请求资源的某个部分，即返回码是 206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。

- 错误通知的管理

  在 HTTP/1.1 中新增了 24 个错误状态响应码，如 409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。

- Host 头处理

  在 HTTP/1.1 中认为每台服务器都绑定一个唯一的 IP 地址，因此，请求消息中的 URL 并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个 IP 地址。HTTP1.1 的请求消息和响应消息都应支持 Host 头域，且请求消息中如果没有 Host 头域会报告一个错误（400 Bad Request）。

- 长连接

  HTTP 1.1 支持长连接（PersistentConnection）和请求的流水线（Pipelining）处理，在一个 TCP 连接上可以传送多个 HTTP 请求和响应，减少了建立和关闭连接的消耗和延迟，在 HTTP/1.1 中默认开启 Connection： keep-alive，一定程度上弥补了 HTTP/1.0 每次请求都要创建连接的缺点。

## 主要特点

1. 简单快速：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有 GET、HEAD、POST。每种方法规定了客户与服务器联系的类型不同。由于 HTTP 协议简单，使得 HTTP 服务器的程序规模小，因而通信速度很快。

2. 灵活：HTTP 允许传输任意类型的数据对象。正在传输的类型由 Content-Type 加以标记。

3. 无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。

4. 无状态：HTTP 协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。

5. 支持 B/S (浏览器/服务器) 及 C/S (客户机/服务器) 模式。

## HTTP 请求结构

HTTP 请求由三部分组成，分别是：请求行、消息报头、请求正文

- 请求方法

  根据 HTTP 标准，HTTP 请求可以使用多种请求方法。
  HTTP/1.0 定义了三种请求方法： GET, POST 和 HEAD 方法。
  HTTP/1.1 新增了五种请求方法：OPTIONS, PUT, DELETE, TRACE 和 CONNECT 方法。

  - GET： 用于请求访问已经被 URL（统一资源标识符）识别的资源，可以通过 URL 传参给服务器。
  - POST：用于传输信息给服务器，主要功能与 GET 方法类似，但一般推荐使用 POST 方式。
  - PUT： 传输文件，报文主体中包含文件内容，保存到对应 URL 位置。
  - HEAD： 获得报文首部，与 GET 方法类似，只是不返回报文主体，一般用于验证 URL 是否有效。
  - DELETE：删除文件，与 PUT 方法相反，删除对应 URL 位置的文件。
  - OPTIONS：查询相应 URL 支持的 HTTP 方法。
  - TRACE 请求服务器回送收到的请求信息，主要用于测试或诊断
  - CONNECT 保留将来使用

- 状态代码

  状态代码有三位数字组成，第一个数字定义了响应的类别，共分五种类别:

  - 1xx：指示信息--表示请求已接收，继续处理
  - 2xx：成功--表示请求已被成功接收、理解、接受
  - 3xx：重定向--要完成请求必须进行更进一步的操作
  - 4xx：客户端错误--请求有语法错误或请求无法实现
  - 5xx：服务器端错误--服务器未能实现合法的请求

  常见状态码：

  - 200 OK //客户端请求成功
  - 400 Bad Request //客户端请求有语法错误，不能被服务器所理解
  - 401 Unauthorized //请求未经授权，这个状态代码必须和 WWW-Authenticate 报头域一起使用
  - 403 Forbidden //服务器收到请求，但是拒绝提供服务
  - 404 Not Found //请求资源不存在，eg：输入了错误的 URL
  - 500 Internal Server Error //服务器发生不可预期的错误
  - 503 Server Unavailable //服务器当前不能处理客户端的请求，一段时间后可能恢复正常

  [菜鸟教程更多状态码](http://www.runoob.com/http/http-status-codes.html)

## HTTP 缺点

- 连接无法复用

  连接无法复用会导致每次请求都经历三次握手和慢启动。三次握手在高延迟的场景下影响较明显，慢启动则对大量小文件请求影响较大（没有达到最大窗口请求就被终止）。

  - HTTP/1.0 传输数据时，每次都需要重新建立连接，增加延迟。
  - HTTP/1.1 虽然加入 keep-alive 可以复用一部分连接，但域名分片等情况下仍然需要建立多个 connection，耗费资源，给服务器带来性能压力。

- Head-Of-Line Blocking（HOLB）浏览器阻塞

  HTTP/1.1 的持久连接和管道机制允许复用 TCP 连接，在一个 TCP 连接中，也可以同时发送多个请求，但是所有的数据通信都是按次序完成的，服务器只有处理完一个回应，才会处理下一个回应。比如客户端需要 A、B 两个资源，管道机制允许浏览器同时发出 A 请求和 B 请求，但服务器还是按照顺序，先回应 A 请求，完成后再回应 B 请求，这样如果前面的回应特别慢，后面就会有很多请求排队等着，这称为“队头阻塞（Head-of-line blocking）”。
  浏览器对于同一个域名，同时只能有 6 个连接（这个根据浏览器内核不同可能会有所差异），超过浏览器最大连接数限制，后续请求就会被阻塞。

  > 所以有的网站会使用多个静态资源 CDN 域名来规避浏览器对同一域名请求数量的限制。目的就是变相的解决浏览器针对同一域名的请求限制阻塞问题。

  - HTTP/1.0：下个请求必须在前一个请求返回后才能发出，request-response 对按序发生。显然，如果某个请求长时间没有返回，那么接下来的请求就全部阻塞了。

  - HTTP/1.1：尝试使用 pipeling 来解决，即浏览器可以一次性发出多个请求（同个域名，同一条 TCP 链接）。但 pipeling 要求返回是按序的，那么前一个请求如果很耗时（比如处理大图片），那么后面的请求即使服务器已经处理完，仍会等待前面的请求处理完才开始按序返回。所以，pipeling 只部分解决了 HOLB。

- dns 延迟

  DNS 查询（DNS Lookup）：将域名解析为 IP 就是 DNS 查询，一般使用 DNS 缓存来减少这个时间。

- 协议开销大

  HTTP1.x 在使用时，header 里携带的内容过大，在一定程度上增加了传输的成本，并且每次请求 header 基本不怎么变化。

- 安全因素

  HTTP1.x 在传输数据时，所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份，这在一定程度上无法保证数据的安全性

## HTTPS

HTTPS 的全称是 Hypertext Transfer Protocol Secure，它用来在计算机网络上的两个端系统之间进行安全的交换信息(secure communication)，它相当于在 HTTP 的基础上加了一个 Secure 安全的词眼，那么我们可以给出一个 HTTPS 的定义：HTTPS 是一个在计算机世界里专门在两点之间安全的传输文字、图片、音频、视频等超文本数据的约定和规范。 HTTPS 是 HTTP 协议的一种扩展，它本身并不保传输的证安全性，那么谁来保证安全性呢？在 HTTPS 中，使用传输层安全性(TLS)或安全套接字层(SSL)对通信协议进行加密。也就是 HTTP + SSL(TLS) = HTTPS。

### 工作流程

SSL/TLS 的基本思路是公钥加密法：客户端先向服务器索要并验证公钥，然后用公钥加密传输来协商生成“对话秘钥”（非对称加密），双方采用“对话秘钥”进行加密通信（对称加密）。

通信过程如下：

1. 客户端发出请求：给出支持的协议版本、支持的加密方法（如 RSA 公钥加密）以及一个客户端生成的随机数（Client random）

2. 服务端回应：确认双方通信的协议版本、加密方法，并给出服务器证书以及一个服务器生成的随机数（Server random）；

3. 客户端回应：客户端确认证书有效，取出证书中的公钥，然后生成一个新的随机数（Premaster secret），使用公钥加密这个随机数，发送给服务端；

4. 服务端回应：服务端使用自己的私钥解密客户端发来的随机数（Premaster secret），客户端和服务端根据约定的加密方法，使用三个随机数，生成 “对话秘钥”；

5. 会话通信：客户端和服务端使用“对话秘钥”加密通信，这个过程完全使用普通的 HTTP 协议，只不过用“会话秘钥”加密内容。

前四步称为握手阶段，用于客户端和服务端建立连接和交换参数。整个通信过程可用下图所示：

![https 流程](https://cdn.clearlywind.com/blog-images/images/https-work-flow.png)

- 其他特点

  - 缓存：只要在 HTTP 头中使用特定命令，就可以缓存 HTTPS；
  - 延迟：HTTP 耗时 = TCP 握手；HTTPS 耗时 = TCP 握手 + SSL 握手。SSL 握手耗时大概是 TCP 握手耗时的三倍左右。

## HTTP/2

维基百科关于 HTTP/2 的介绍，可以看下定义和发展历史:[wiki](https://zh.wikipedia.org/zh-hans/HTTP/2)

[这个网站可以对比 HTTP/1.x 和 HTTP/2 性能](https://http2.akamai.com/demo)

### 新特性

众所周知 ，在 HTTP/1.1 协议中，浏览器客户端在同一时间，针对同一域名下的请求有一定数量限制。超过限制数目的请求会被阻塞」。

优 HTTP/2 相比于 HTTP/1.x，大幅提升了 web 性能，减少网络延迟。其中包括：

- 单一长连接多路复用

  在 HTTP/2 中，客户端向某个域名的服务器请求页面的过程中，只会创建一条 TCP 连接，即使这页面可能包含上百个资源。 单一的连接应该是 HTTP2 的主要优势，单一的连接能减少 TCP 握手带来的时延。HTTP2 中用一条单一的长连接，避免了创建多个 TCP 连接带来的网络开销，提高了吞吐量。

  HTTP2 虽然只有一条 TCP 连接，但是在逻辑上分成了很多 stream。 HTTP2 把要传输的信息分割成一个个二进制帧，首部信息会被封装到 HEADER Frame，相应的 request body 就放到 DATA Frame, 一个帧你可以看成路上的一辆车，只要给这些车编号，让 1 号车都走 1 号门出，2 号车都走 2 号门出，就把不同的 HTTP 请求或者响应区分开来了。但是，这里要求同一个请求或者响应的帧必须是有有序的，要保证 FIFO 的，但是不同的请求或者响应帧可以互相穿插。这就是 HTTP2 的多路复用，是不是充分利用了网络带宽，是不是提高了并发度？

- 头部压缩和二进制格式

  HTTP/1.x 一直都是 plain text, 对此我只能想到一个优点，便于阅读和 debug。但是，现在很多都走 HTTPS 也把 plain text 变成了二进制，那这个优点也没了。于是 HTTP2 搞了个 HPACK 压缩来压缩头部，减少报文大小(调试这样的协议将需要 curl 这样的工具，要进一步地分析网络数据流需要类似 Wireshark 的 HTTP2 解析器)。

- 服务端推动 Sever Push

  这个功能通常被称作“缓存推送”。主要的思想是：当一个客户端请求资源 X，而服务器知道它很可能也需要资源 Z 的情况下，服务器可以在客户端发送请求前，主动将资源 Z 推送给客户端。这个功能帮助客户端将 Z 放进缓存以备将来之需。

## 三版 HTTP 协议对比

![三种HTTP协议对比](https://cdn.clearlywind.com/blog-images/images/http-3-types.png)

HTTP 三个主要版本对 TCP 连接的使用差异对比。① HTTP/1 版本里，每个 TCP 只能用于一次 HTTP 通信，完成后会立即关闭。每个 HTTP 请求都需要重新建立 TCP 连接。② HTTP/1.1 增加了 `Connection: keep-alive` 首部，允许持久连接的 TCP。③ HTTP/2 则允许在同一个 TCP 连接里同时进行多个 HTTP 请求/响应会话。（本图参考[5]绘制）。假设网络带宽都足够大，那么 HTTP/2 的方案则明显可以很大程度上降低整个页面的网络延时。

### 如何启用

- nginx
  如果是编译安装的 nginx，则需要在编译过程中添加参数 `–with-http_v2_module`

  ```conf
  server {
    listen 443 ssl http2;
    server_name localhost;
    ssl_certificate server.crt;
    ssl_certificate_key server.key;
  }
  ```

  > 浏览器如何查看 HTTP 版本
  > Chrome=>F12=>Network=>Tab 栏右键点击=>勾选 Protocol

## 参考地址

[HTTP/1.0、HTTP/1.1、HTTP/2、HTTPS](https://zhuanlan.zhihu.com/p/43787334)

[知乎: HTTP/2 相比 1.0 有哪些重大改进？](https://www.zhihu.com/question/34074946)

[参考链接](https://zhuanlan.zhihu.com/p/29609078)
